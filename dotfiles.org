#+TITLE: Dotfiles configuration
#+AUTHOR: Mario Forzanini
#+PROPERTY: header-args :mkdirp yes
* Rationale
* General
  Let's define some environment variables needed to properly tangle
  the configurations. Adding new systems is as easy as adding
  conditions to these variable setup.
  #+begin_src emacs-lisp
	(setq mf/host-machine
		  (let ((hostname (with-temp-buffer
							(insert-file-contents "/etc/hostname")
							(seq-subseq (buffer-string) 0 (1- (length (buffer-string)))))))
			(cond
			 ((string= hostname "seneca")
			  "desktop")
			 ((string= hostname "catullo")
			  "laptop"))))

	(setq mf/host-os
		  (cond
		   ((executable-find "xbps-install")
			  "void")
		   ((executable-find "kiss")
			"kiss")
		   (t
			"linux")))
  #+end_src
** Font
   I use the [[https://google.com/fonts][croscore-fonts]].
   #+NAME: font
   #+begin_src conf
		 Cousine
   #+end_src
   I also like bigger fonts on my desktop:
#+NAME: font-size
   #+begin_src emacs-lisp
  (if (string= mf/host-machine "desktop")
	  18
	12)
   #+end_src
** Privilege excalation program
   I use two different privilege excalation programs on my systems: in
   KISS linux I use [[https://github.com/illiliti/ssu][ssu]], while in Void I use [[https://github.com/Duncaen/OpenDoas][opendoas]]
   #+NAME: privilege-program
   #+begin_src emacs-lisp
	 (cond
	  ((string= mf/host-os "void")
	   (executable-find "doas"))
	  ((string= mf/host-os "kiss")
	   (executable-find "kiss")))
   #+end_src
** Scripts
   My =scripts/= folder holds some (mostly obsolete scripts), most of
   these worked as glue between various different programs I don't use
   anymore. I'll install them under =$HOME/.local/bin/scripts/=
   anyway, just in case I need them.
   #+begin_src shell :eval t
	 cp -r scripts $HOME/.local/bin/
   #+end_src
** Alsa
   Configure alsa for multi output when using the desktop, where I
   need to have a headset for the microphone to work. A much simpler
   setup will suffice on the laptop.
   #+NAME: alsa-pcms
   #+begin_src emacs-lisp
	 (if (string= mf/host-machine "desktop")
		 "pcm.usbaudio {
				   type dmix
				   ipc_key 1024
				   slave {
						 pcm \"hw:2,0\"
						 period_time 0
						 period_size 1024
						 buffer_size 8192
				   }
	 }

	 pcm.speakers {
				   type dmix
				   ipc_key 2048
				   slave {
						 pcm \"hw:0,0\"
						 period_time 0
						 period_size 1024
						 buffer_size 8192
				   }
	 }
	 "
						 "")
   #+end_src
   Setup the default pcm.
   #+NAME: alsa-default
   #+begin_src emacs-lisp
	 (if (string= mf/host-machine "desktop")
		 "type plug
	 slave.pcm speakers"
	   "type asym
	 capture.pcm "plughw:0"
	 playback.pcm {
		   type plug
		   slave.pcm dmix
	 }")
   #+end_src
   #+begin_src conf :tangle .asoundrc :noweb yes
	 # https://alsa.opensrc.org/Dmix
	 <<alsa-pcms()>>
	 pcm.!default {
				  # slave.pcm usbaudio
				  <<alsa-default()>>	
	 }
   #+end_src
** .profile
   :PROPERTIES:
   :header-args:shell: :tangle .profile
   :END:
   I use the =$HOME/.profile= file to handle environment
   variables, but some of them are only useful if used in KISS hosts
   (like =KISS_PATH=).
   #+NAME: kiss-path
   #+begin_src emacs-lisp
	 (if (string= mf/host-os "kiss")
		 "KISS_PATH=\"/var/repos/repo/core\"
	 KISS_PATH=\"/var/repos/repo/extra:${KISS_PATH}\"
	 KISS_PATH=\"/var/repos/repo/wayland:${KISS_PATH}\"
	 KISS_PATH=\"/var/repos/community/community:${KISS_PATH}\"
	 KISS_PATH=\"$HOME/personalRepos:${KISS_PATH}\"
	 export KISS_PATH"
	   "")
   #+end_src
   #+begin_src shell :noweb yes
	 #!/bin/sh
	 # Compilation
	 MAKEFLAGS="-j$(nproc)"
	 CFLAGS="-O3 -pipe -march=native"
	 CXXFLAGS="${CFLAGS}"

	 # Global variables
	 EDITOR="emacsclient"
	 VISUAL="${EDITOR}"
	 LANG=en_US.UTF-8

	 PATH="$HOME/go/bin:$PATH"
	 PATH="$HOME/.local/bin:$PATH"
	 PATH="$HOME/.local/bin/scripts:$PATH"

	 <<kiss-path()>>
	 export CFLAGS CXXFLAGS EDITOR LANG MAKEFLAGS PATH VISUAL
   #+end_src
* Xorg
  I need this on my [[https://voidlinux.org][void-linux]] systems where I use X11.
** DWM
   :PROPERTIES:
   :header-args:diff: :tangle dwm/mf-dwm.patch
   :END:
   My [[https://dwm.suckless.org][DWM]] setup is pretty simple and sticks to the defaults for the
   most part, I don't like applying tons of patches because I consider
   the defaults to be enough for my usecase. I do tweak some things,
   so I periodically produce a /diff/ that I use to patch the git
   uptsream.

   All of my configuration happens in config.def.h, so let's remove
   =config.h= when we issue =make clean=
	#+begin_src diff
	  diff --git a/Makefile b/Makefile
	  index 77bcbc0..e961e35 100644
	  --- a/Makefile
	  +++ b/Makefile
	  @@ -26,7 +26,7 @@ dwm: ${OBJ}
		  ${CC} -o $@ ${OBJ} ${LDFLAGS}
 
	   clean:
	  -	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
	  +	rm -f config.h dwm ${OBJ} dwm-${VERSION}.tar.gz
 
	   dist: clean
		  mkdir -p dwm-${VERSION}
	#+end_src
	Let's tweak the appearance of the bar a little bit, and let's add
	gaps. I use bright colors borrowed from Plan 9's [[http://acme.cat-v.org][Acme]] editor.
	#+begin_src diff :noweb yes
	  diff --git a/config.def.h b/config.def.h
	  index a2ac963..abd211d 100644
	  --- a/config.def.h
	  +++ b/config.def.h
	  @@ -2,115 +2,121 @@

	   /* appearance */
	   static const unsigned int borderpx  = 1;        /* border pixel of windows */
	  +static const int startwithgaps	     = 1;	 /* 1 means gaps are used by default */
	  +static const unsigned int gappx     = 10;       /* default gap between windows in pixels */
	   static const unsigned int snap      = 32;       /* snap pixel */
	  -static const int showbar            = 1;        /* 0 means no bar */
	  +static const int showbar            = 0;        /* 0 means no bar */
	   static const int topbar             = 1;        /* 0 means bottom bar */
	  -static const char *fonts[]          = { "monospace:size=10" };
	  -static const char dmenufont[]       = "monospace:size=10";
	  -static const char col_gray1[]       = "#222222";
	  -static const char col_gray2[]       = "#444444";
	  -static const char col_gray3[]       = "#bbbbbb";
	  -static const char col_gray4[]       = "#eeeeee";
	  -static const char col_cyan[]        = "#005577";
	  +static const char *fonts[]          = { "<<font>>:size=<<font-size()>>" };
	  +static const char dmenufont[]       = "<<font>>:size=<<font-size()>>";
	  +/* static const char col_gray1[]       = "#222222"; */
	  +/* static const char col_gray2[]       = "#444444"; */
	  +/* static const char col_gray3[]       = "#bbbbbb"; */
	  +/* static const char col_gray4[]       = "#eeeeee"; */
	  +/* static const char col_cyan[]        = "#005577"; */
	  +/* Acme theme */
	  +static const char col_gray1[]       = "#ffffea";
	  +static const char col_gray2[]       = "#000000";
	  +static const char col_gray3[]       = "#000000";
	  +static const char col_gray4[]       = "#000000";
	  +static const char col_cyan[]        = "#eaffff";
	   static const char *colors[][3]      = {
	  -	/*               fg         bg         border   */
	  -	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
	  -	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
	  +        /*               fg         bg         border   */
	  +        [SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
	  +        [SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
	   };
 
	#+end_src
	I like having only 3 tags by default, 10 is way too much.
	#+begin_src diff
 	   /* tagging */
	  -static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
	  +static const char *tags[] = { "I", "II", "III"};
 
	#+end_src
	I only need two simple rules:
	- One to move =firefox= instances to the second tag
	- One to move =mpv= instances to the third tag
	#+begin_src diff
	   static const Rule rules[] = {
	  -	/* xprop(1):
	  -	 *	WM_CLASS(STRING) = instance, class
	  -	 *	WM_NAME(STRING) = title
	  -	 */
	  -	/* class      instance    title       tags mask     isfloating   monitor */
	  -	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
	  -	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
	  +        /* xprop(1):
	  +         *	WM_CLASS(STRING) = instance, class
	  +         *	WM_NAME(STRING) = title
	  +         */
	  +        /* class      instance    title       tags mask     isfloating   monitor */
	  +        { "Firefox",  NULL,       NULL,       1 << 1,       0,           -1 },
	  +        { "mpv",      NULL,       NULL,       1 << 2,       0,           -1 },
	   };

	#+end_src
	Set =resizehints= to 0 to avoid weird window geometry.
	#+begin_src diff
	   /* layout(s) */
	   static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
	   static const int nmaster     = 1;    /* number of clients in master area */
	  -static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
	  -static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
	  +static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
 
	   static const Layout layouts[] = {
	  -	/* symbol     arrange function */
	  -	{ "[]=",      tile },    /* first entry is default */
	  -	{ "><>",      NULL },    /* no layout function means floating behavior */
	  -	{ "[M]",      monocle },
	  +        /* symbol     arrange function */
	  +        { "[]=",      tile },    /* first entry is default */
	  +        { "><>",      NULL },    /* no layout function means floating behavior */
	  +        { "[M]",      monocle },
	   };

	#+end_src
*** Keybindings
	This is the only big change, I use =Mod4Mask= (aka the super key)
	as my modifier, and I define some simple commands to control the
	volume, launch Emacs and st.
	 #+begin_src diff
		/* key definitions */
	   -#define MODKEY Mod1Mask
	   +#define MODKEY Mod4Mask
		#define TAGKEYS(KEY,TAG) \
	   -	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
	   -	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
	   -	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
	   -	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
	   +{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
	   +{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
	   +{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
	   +{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
 
		/* helper for spawning shell commands in the pre dwm-5.0 fashion */
		#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
		/* commands */
		static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
	   -static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
	   +static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, NULL};
		static const char *termcmd[]  = { "st", NULL };
	   +static const char *emacscmd[] = { "emacs", NULL };
	   +static const char *lowervol[] = { "amixer", "sset", "Master", "5%-", NULL};
	   +static const char *raisevol[] = { "amixer", "sset", "Master", "5%+", NULL};

	 #+end_src
	 Change a lot of default keybindings:
	 | Key    | Action       |
	 |--------+--------------|
	 | Minus  | lower volume |
	 | Plus   | raise volume |
	 | Space  | zoom         |
	 | Return | st           |
	 | r      | dmenu        |
	 | b      | toggle bar   |
	 | f      | fullscreen   |
	 | q      | kill client  |
	 #+begin_src diff
		static Key keys[] = {
	   -	/* modifier                     key        function        argument */
	   -	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
	   -	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
	   -	{ MODKEY,                       XK_b,      togglebar,      {0} },
	   -	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
	   -	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
	   -	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
	   -	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
	   -	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
	   -	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
	   -	{ MODKEY,                       XK_Return, zoom,           {0} },
	   -	{ MODKEY,                       XK_Tab,    view,           {0} },
	   -	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
	   -	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
	   -	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
	   -	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
	   -	{ MODKEY,                       XK_space,  setlayout,      {0} },
	   -	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
	   -	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
	   -	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
	   -	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
	   -	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
	   -	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
	   -	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
	   -	TAGKEYS(                        XK_1,                      0)
	   -	TAGKEYS(                        XK_2,                      1)
	   -	TAGKEYS(                        XK_3,                      2)
	   -	TAGKEYS(                        XK_4,                      3)
	   -	TAGKEYS(                        XK_5,                      4)
	   -	TAGKEYS(                        XK_6,                      5)
	   -	TAGKEYS(                        XK_7,                      6)
	   -	TAGKEYS(                        XK_8,                      7)
	   -	TAGKEYS(                        XK_9,                      8)
	   -	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
	   +        /* modifier                     key        function        argument */
	   +        { MODKEY,                       XK_r,      spawn,          {.v = dmenucmd } },
	   +        { MODKEY,                       XK_Return, spawn,          {.v = termcmd  } },
	   +        { MODKEY,                       XK_minus,  spawn,          {.v = lowervol } },
	   +        { MODKEY|ShiftMask,             XK_equal,  spawn,          {.v = raisevol } },
	   +        { MODKEY,                       XK_e,      spawn,          {.v = emacscmd } },
	   +        { MODKEY,                       XK_b,      togglebar,      {0} },
	   +        { MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
	   +        { MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
	   +        { MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
	   +        { MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
	   +        { MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
	   +        { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
	   +        { MODKEY,                       XK_space,  zoom,           {0} },
	   +        { MODKEY,                       XK_Tab,    view,           {0} },
	   +        { MODKEY,                       XK_q,      killclient,     {0} },
	   +        { MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
	   +        { MODKEY,                       XK_f,      setlayout,      {.v = &layouts[2]} },
	   +        { MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
	   +        { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
	   +        { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
	   +        { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
	   +        { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
	   +        { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
	   +        { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
	   +		{ MODKEY,                       XK_g,      setgaps,        {.i = GAP_TOGGLE} },
	   +        TAGKEYS(                        XK_1,                      0)
	   +		TAGKEYS(                        XK_2,                      1)
	   +		TAGKEYS(                        XK_3,                      2)
	   +		TAGKEYS(                        XK_4,                      3)
	   +		{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
		};
 
		/* button definitions */
		/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
		static Button buttons[] = {
	   -	/* click                event mask      button          function        argument */
	   -	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
	   -	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
	   -	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
	   -	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
	   -	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
	   -	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
	   -	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
	   -	{ ClkTagBar,            0,              Button1,        view,           {0} },
	   -	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
	   -	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
	   -	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
	   +        /* click                event mask      button          function        argument */
	   +        { ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
	   +        { ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
	   +        { ClkWinTitle,          0,              Button2,        zoom,           {0} },
	   +        { ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
	   +        { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
	   +        { ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
	   +        { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
	   +        { ClkTagBar,            0,              Button1,        view,           {0} },
	   +        { ClkTagBar,            0,              Button3,        toggleview,     {0} },
	   +        { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
	   +        { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
		};
	   -
	 #+end_src
*** Gaps
	Add gaps around windows. This is basically the [[https://dwm.suckless.org/patches/functionalgaps][functionalgaps]] patch.
	#+begin_src diff
	  diff --git a/dwm.c b/dwm.c
	  index 5e4d494..34490eb 100644
	  --- a/dwm.c
	  +++ b/dwm.c
	  @@ -57,6 +57,9 @@
	   #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
	   #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
 
	  +#define GAP_TOGGLE 100
	  +#define GAP_RESET  0
	  +
	   /* enums */
	   enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
	   enum { SchemeNorm, SchemeSel }; /* color schemes */
	  @@ -119,6 +122,8 @@ struct Monitor {
		  int by;               /* bar geometry */
		  int mx, my, mw, mh;   /* screen size */
		  int wx, wy, ww, wh;   /* window area  */
	  +	int gappx;	      /* gaps between windows */
	  +	int drawwithgaps;     /* toggle gaps */
		  unsigned int seltags;
		  unsigned int sellt;
		  unsigned int tagset[2];
	  @@ -200,6 +205,7 @@ static void sendmon(Client *c, Monitor *m);
	   static void setclientstate(Client *c, long state);
	   static void setfocus(Client *c);
	   static void setfullscreen(Client *c, int fullscreen);
	  +static void setgaps(const Arg *arg);
	   static void setlayout(const Arg *arg);
	   static void setmfact(const Arg *arg);
	   static void setup(void);
	  @@ -639,6 +645,8 @@ createmon(void)
		  m->nmaster = nmaster;
		  m->showbar = showbar;
		  m->topbar = topbar;
	  +	m->gappx = gappx;
	  +	m->drawwithgaps = startwithgaps;
		  m->lt[0] = &layouts[0];
		  m->lt[1] = &layouts[1 % LENGTH(layouts)];
		  strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
	  @@ -797,6 +805,12 @@ focus(Client *c)
			  attachstack(c);
			  grabbuttons(c, 1);
			  XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
	  +                if (!selmon->drawwithgaps && !c->isfloating) {
	  +			XWindowChanges wc;
	  +                        wc.sibling = selmon->barwin;
	  +                        wc.stack_mode = Below;
	  +                        XConfigureWindow(dpy, c->win, CWSibling | CWStackMode, &wc);
	  +                }
			  setfocus(c);
		  } else {
			  XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
	  @@ -835,7 +849,7 @@ focusstack(const Arg *arg)
	   {
		  Client *c = NULL, *i;
 
	  -	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
	  +	if (!selmon->sel || selmon->sel->isfullscreen)
			  return;
		  if (arg->i > 0) {
			  for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
	  @@ -1113,7 +1127,10 @@ monocle(Monitor *m)
		  if (n > 0) /* override layout symbol */
			  snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
		  for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
	  -		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
	  +		if (selmon->drawwithgaps)
	  +			resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
	  +		else
	  +			resize(c, m->wx - c->bw, m->wy, m->ww, m->wh, False);
	   }
 
	   void
	  @@ -1283,6 +1300,15 @@ resizeclient(Client *c, int x, int y, int w, int h)
		  c->oldw = c->w; c->w = wc.width = w;
		  c->oldh = c->h; c->h = wc.height = h;
		  wc.border_width = c->bw;
	  +	if (!selmon->drawwithgaps && /* this is the noborderfloatingfix patch, slightly modified so that it will work if, and only if, gaps are disabled. */
	  +	    (((nexttiled(c->mon->clients) == c && !nexttiled(c->next)) /* these two first lines are the only ones changed. if you are manually patching and have noborder installed already, just change these lines; or conversely, just remove this section if the noborder patch is not desired ;) */
	  +	    || &monocle == c->mon->lt[c->mon->sellt]->arrange))
	  +	    && !c->isfullscreen && !c->isfloating
	  +	    && NULL != c->mon->lt[c->mon->sellt]->arrange) {
	  +	        c->w = wc.width += c->bw * 2;
	  +	        c->h = wc.height += c->bw * 2;
	  +	        wc.border_width = 0;
	  +	}
		  XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
		  configure(c);
		  XSync(dpy, False);
	  @@ -1498,6 +1524,26 @@ setfullscreen(Client *c, int fullscreen)
		  }
	   }
 
	  +void
	  +setgaps(const Arg *arg)
	  +{
	  +	switch(arg->i)
	  +	{
	  +		case GAP_TOGGLE:
	  +			selmon->drawwithgaps = !selmon->drawwithgaps;
	  +			break;
	  +		case GAP_RESET:
	  +			selmon->gappx = gappx;
	  +			break;
	  +		default:
	  +			if (selmon->gappx + arg->i < 0)
	  +				selmon->gappx = 0;
	  +			else
	  +				selmon->gappx += arg->i;
	  +	}
	  +	arrange(selmon);
	  +}
	  +
	   void
	   setlayout(const Arg *arg)
	   {
	  @@ -1680,23 +1726,42 @@ tile(Monitor *m)
		  for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
		  if (n == 0)
			  return;
	  -
	  -	if (n > m->nmaster)
	  -		mw = m->nmaster ? m->ww * m->mfact : 0;
	  -	else
	  -		mw = m->ww;
	  -	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
	  -		if (i < m->nmaster) {
	  -			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
	  -			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
	  -			if (my + HEIGHT(c) < m->wh)
	  -				my += HEIGHT(c);
	  -		} else {
	  -			h = (m->wh - ty) / (n - i);
	  -			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
	  -			if (ty + HEIGHT(c) < m->wh)
	  -				ty += HEIGHT(c);
	  -		}
	  +        if (m->drawwithgaps) { /* draw with fullgaps logic */
	  +                if (n > m->nmaster)
	  +                        mw = m->nmaster ? m->ww * m->mfact : 0;
	  +                else
	  +                        mw = m->ww - m->gappx;
	  +                for (i = 0, my = ty = m->gappx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
	  +                        if (i < m->nmaster) {
	  +                                h = (m->wh - my) / (MIN(n, m->nmaster) - i) - m->gappx;
	  +                                resize(c, m->wx + m->gappx, m->wy + my, mw - (2*c->bw) - m->gappx, h - (2*c->bw), 0);
	  +                                if (my + HEIGHT(c) + m->gappx < m->wh)
	  +                                        my += HEIGHT(c) + m->gappx;
	  +                        } else {
	  +                                h = (m->wh - ty) / (n - i) - m->gappx;
	  +                                resize(c, m->wx + mw + m->gappx, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappx, h - (2*c->bw), 0);
	  +                                if (ty + HEIGHT(c) + m->gappx < m->wh)
	  +                                        ty += HEIGHT(c) + m->gappx;
	  +                        }
	  +        } else { /* draw with singularborders logic */
	  +                if (n > m->nmaster)
	  +                        mw = m->nmaster ? m->ww * m->mfact : 0;
	  +                else
	  +                        mw = m->ww;
	  +                for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
	  +                        if (i < m->nmaster) {
	  +                                h = (m->wh - my) / (MIN(n, m->nmaster) - i);
	  +                                if (n == 1)
	  +                                        resize(c, m->wx - c->bw, m->wy, m->ww, m->wh, False);
	  +                                else
	  +                                        resize(c, m->wx - c->bw, m->wy + my, mw - c->bw, h - c->bw, False);
	  +                                my += HEIGHT(c) - c->bw;
	  +                        } else {
	  +                                h = (m->wh - ty) / (n - i);
	  +                                resize(c, m->wx + mw - c->bw, m->wy + ty, m->ww - mw, h - c->bw, False);
	  +                                ty += HEIGHT(c) - c->bw;
	  +                        }
	  +        }
	   }
 
	   void

	#+end_src
*** Setup
	To get the configuration going, simply apply the patch and rebuild
	dwm. The executable will be installed under =/usr/local/bin=, so
	we need root privileges to run =make install=.
	#+begin_src shell
	  cd dwm
	  patch -p1 < mf-dwm.patch
	  make clean
	  make
	  <<privilege-program()>> make install
	#+end_src
** DMENU
   :PROPERTIES:
   :header-args:diff: :tangle dmenu/mf-dmenu.patch
   :END:
   Similarly to dwm I customize [[https://tools.suckless.org/dmenu][dmenu]] very little, because I think the
   defaults are pretty sane. I actually only change the font.
   #+begin_src diff :noweb yes
	 diff --git a/config.def.h b/config.def.h
	 index 1edb647..3964f91 100644
	 --- a/config.def.h
	 +++ b/config.def.h
	 @@ -4,7 +4,7 @@
	  static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom     */
	  /* -fn option overrides fonts[0]; default X11 font or font set */
	  static const char *fonts[] = {
	 -	"monospace:size=10"
	 +	"<<font>>:size=<<font-size()>>"
	  };
	  static const char *prompt      = NULL;      /* -p  option; prompt to the left of input field */
	  static const char *colors[SchemeLast][2] = {
   #+end_src
** ST
   :PROPERTIES:
   :header-args:diff: :tangle st/mf-st.patch
   :END:
   My st configuration is a bit more elaborate, because I add
   transparency and scrolling to the default build.
*** Font
   First of all let's change the font.
   #+begin_src diff :noweb yes
	 diff --git a/config.def.h b/config.def.h
	 index 6f05dce..9f3cb26 100644
	 --- a/config.def.h
	 +++ b/config.def.h
	 @@ -5,8 +5,10 @@
	   ,*
	   ,* font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html
	   ,*/
	 -static char *font = "Liberation Mono:pixelsize=12:antialias=true:autohint=true";
	 -static int borderpx = 2;
	 +
	 +static char *font = "<<font>>:pixelsize=<<font-size()>>:antialias=true:autohint=true";
	 +static char *font2[] = { "Font Awesome:pixelsize=12"};
	 +static int borderpx = 0;
 
	  /*
	   ,* What program is execed by st depends of these precedence rules:

   #+end_src
*** Transparency
	I currently don't use transparency because of the Acme colorscheme
	that I chose.
	#+begin_src diff
	  @@ -93,6 +95,9 @@ char *termname = "st-256color";
		,*/
	   unsigned int tabspaces = 8;
 
	  +/* bg opacity*/
	  +float alpha = 1;
	  +
	   /* Terminal colors (16 first used in escape sequence) */
	   static const char *colorname[] = {
		  /* 8 normal colors */
	#+end_src
*** Colorscheme
	Setup the acme colorscheme.
	#+begin_src diff
	  @@ -101,37 +106,38 @@ static const char *colorname[] = {
		  "green3",
		  "yellow3",
		  "blue2",
	  +	/*"#900000",*/
		  "magenta3",
		  "cyan3",
		  "gray90",
	  -
	  +	/**/
		  /* 8 bright colors */
		  "gray50",
	  -	"red",
	  +	/*"red",*/
	  +	"blue2",
		  "green",
		  "yellow",
	  -	"#5c5cff",
	  +	/*"blue2",*/
	  +	"#900000",
		  "magenta",
		  "cyan",
		  "white",
 
		  [255] = 0,
 
	  -	/* more colors can be added after 255 to use with DefaultXX */
	  +	/* More colors can be added after 255 to use with DefaultXX */
		  "#cccccc",
		  "#555555",
	  +	"black",
	   };
 
 
	  -/*
	  - * Default colors (colorname index)
	  - * foreground, background, cursor, reverse cursor
	  - */
	  +
	  +/*Default colors (colorname index) foreground, background, cursor*/
	   unsigned int defaultfg = 7;
	  -unsigned int defaultbg = 0;
	  +unsigned int defaultbg = 258;
	   static unsigned int defaultcs = 256;
	  -static unsigned int defaultrcs = 257;
	  -
	  +static unsigned int defaultrcs =257;
	   /*
		,* Default shape of cursor
		,* 2: Block ("█")
	#+end_src
*** Everything else
	Setup keybindings to scroll up and down (=Alt+[kj]=) and include
	the [[https://st.suckless.org/patches/alpha][alpha]] and the [[https://st.suckless.org/patches/clipboard][clipboard]] patches.
	#+begin_src diff
	  @@ -175,9 +181,9 @@ static uint forcemousemod = ShiftMask;
	   static MouseShortcut mshortcuts[] = {
		  /* mask                 button   function        argument       release */
		  { XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },
	  -	{ ShiftMask,            Button4, ttysend,        {.s = "\033[5;2~"} },
	  +	{ ShiftMask,            Button4, kscrollup,      {.i = 1} },
		  { XK_ANY_MOD,           Button4, ttysend,        {.s = "\031"} },
	  -	{ ShiftMask,            Button5, ttysend,        {.s = "\033[6;2~"} },
	  +	{ ShiftMask,            Button5, kscrolldown,	 {.i = 1} },
		  { XK_ANY_MOD,           Button5, ttysend,        {.s = "\005"} },
	   };
 
	  @@ -191,14 +197,16 @@ static Shortcut shortcuts[] = {
		  { ControlMask,          XK_Print,       toggleprinter,  {.i =  0} },
		  { ShiftMask,            XK_Print,       printscreen,    {.i =  0} },
		  { XK_ANY_MOD,           XK_Print,       printsel,       {.i =  0} },
	  -	{ TERMMOD,              XK_Prior,       zoom,           {.f = +1} },
	  -	{ TERMMOD,              XK_Next,        zoom,           {.f = -1} },
	  +	{ ControlMask|ShiftMask, XK_equal,       zoom,           {.f = +1} },
	  +	{ ControlMask,          XK_minus,       zoom,           {.f = -1} },
		  { TERMMOD,              XK_Home,        zoomreset,      {.f =  0} },
		  { TERMMOD,              XK_C,           clipcopy,       {.i =  0} },
		  { TERMMOD,              XK_V,           clippaste,      {.i =  0} },
		  { TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
		  { ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
		  { TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
	  +	{ MODKEY,		XK_k,		kscrollup,	{.i = -1} },
	  +	{ MODKEY, 		XK_j,		kscrolldown,	{.i = -1} },
	   };
 
	   /*
	  @@ -467,6 +475,6 @@ static uint selmasks[] = {
		,* of single wide characters.
		,*/
	   static char ascii_printable[] =
	  -	" !\"#$%&'()*+,-./0123456789:;<=>?"
	  -	"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
	  -	"`abcdefghijklmnopqrstuvwxyz{|}~";
	  +" !\"#$%&'()*+,-./0123456789:;<=>?"
	  +"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
	  +"`abcdefghijklmnopqrstuvwxyz{|}~";
	  diff --git a/config.mk b/config.mk
	  index c070a4a..aaa54ff 100644
	  --- a/config.mk
	  +++ b/config.mk
	  @@ -16,7 +16,7 @@ PKG_CONFIG = pkg-config
	   INCS = -I$(X11INC) \
			  `$(PKG_CONFIG) --cflags fontconfig` \
			  `$(PKG_CONFIG) --cflags freetype2`
	  -LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft \
	  +LIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender\
			  `$(PKG_CONFIG) --libs fontconfig` \
			  `$(PKG_CONFIG) --libs freetype2`
 
	  diff --git a/st.c b/st.c
	  index a9338e1..e2dd722 100644
	  --- a/st.c
	  +++ b/st.c
	  @@ -35,6 +35,7 @@
	   #define ESC_ARG_SIZ   16
	   #define STR_BUF_SIZ   ESC_BUF_SIZ
	   #define STR_ARG_SIZ   ESC_ARG_SIZ
	  +#define HISTSIZE      2000
 
	   /* macros */
	   #define IS_SET(flag)		((term.mode & (flag)) != 0)
	  @@ -42,6 +43,9 @@
	   #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
	   #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
	   #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
	  +#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
	  +				term.scr + HISTSIZE + 1) % HISTSIZE] : \
	  +				term.line[(y) - term.scr])
 
	   enum term_mode {
		  MODE_WRAP        = 1 << 0,
	  @@ -115,6 +119,9 @@ typedef struct {
		  int col;      /* nb col */
		  Line *line;   /* screen */
		  Line *alt;    /* alternate screen */
	  +	Line hist[HISTSIZE]; /* history buffer */
	  +	int histi;    /* history index */
	  +	int scr;      /* scroll back */
		  int *dirty;   /* dirtyness of lines */
		  TCursor c;    /* cursor */
		  int ocx;      /* old cursor col */
	  @@ -184,20 +191,20 @@ static void tnewline(int);
	   static void tputtab(int);
	   static void tputc(Rune);
	   static void treset(void);
	  -static void tscrollup(int, int);
	  -static void tscrolldown(int, int);
	  -static void tsetattr(const int *, int);
	  -static void tsetchar(Rune, const Glyph *, int, int);
	  +static void tscrollup(int, int, int);
	  +static void tscrolldown(int, int, int);
	  +static void tsetattr(int *, int);
	  +static void tsetchar(Rune, Glyph *, int, int);
	   static void tsetdirt(int, int);
	   static void tsetscroll(int, int);
	   static void tswapscreen(void);
	  -static void tsetmode(int, int, const int *, int);
	  +static void tsetmode(int, int, int *, int);
	   static int twrite(const char *, int, int);
	   static void tfulldirt(void);
	   static void tcontrolcode(uchar );
	   static void tdectest(char );
	   static void tdefutf8(char);
	  -static int32_t tdefcolor(const int *, int *, int);
	  +static int32_t tdefcolor(int *, int *, int);
	   static void tdeftran(char);
	   static void tstrsequence(uchar);
 
	  @@ -226,10 +233,10 @@ static int iofd = 1;
	   static int cmdfd;
	   static pid_t pid;
 
	  -static const uchar utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
	  -static const uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
	  -static const Rune utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
	  -static const Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
	  +static uchar utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
	  +static uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
	  +static Rune utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
	  +static Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
 
	   ssize_t
	   xwrite(int fd, const char *s, size_t len)
	  @@ -269,14 +276,12 @@ xrealloc(void *p, size_t len)
	   }
 
	   char *
	  -xstrdup(const char *s)
	  +xstrdup(char *s)
	   {
	  -	char *p;
	  -
	  -	if ((p = strdup(s)) == NULL)
	  +	if ((s = strdup(s)) == NULL)
			  die("strdup: %s\n", strerror(errno));
 
	  -	return p;
	  +	return s;
	   }
 
	   size_t
	  @@ -416,10 +421,10 @@ tlinelen(int y)
	   {
		  int i = term.col;
 
	  -	if (term.line[y][i - 1].mode & ATTR_WRAP)
	  +	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
			  return i;
 
	  -	while (i > 0 && term.line[y][i - 1].u == ' ')
	  +	while (i > 0 && TLINE(y)[i - 1].u == ' ')
			  --i;
 
		  return i;
	  @@ -520,7 +525,7 @@ selsnap(int *x, int *y, int direction)
	   {
		  int newx, newy, xt, yt;
		  int delim, prevdelim;
	  -	const Glyph *gp, *prevgp;
	  +	Glyph *gp, *prevgp;
 
		  switch (sel.snap) {
		  case SNAP_WORD:
	  @@ -528,7 +533,7 @@ selsnap(int *x, int *y, int direction)
			   ,* Snap around if the word wraps around at the end or
			   ,* beginning of a line.
			   ,*/
	  -		prevgp = &term.line[*y][*x];
	  +		prevgp = &TLINE(*y)[*x];
			  prevdelim = ISDELIM(prevgp->u);
			  for (;;) {
				  newx = *x + direction;
	  @@ -543,14 +548,14 @@ selsnap(int *x, int *y, int direction)
						  yt = *y, xt = *x;
					  else
						  yt = newy, xt = newx;
	  -				if (!(term.line[yt][xt].mode & ATTR_WRAP))
	  +				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
						  break;
				  }
 
				  if (newx >= tlinelen(newy))
					  break;
 
	  -			gp = &term.line[newy][newx];
	  +			gp = &TLINE(newy)[newx];
				  delim = ISDELIM(gp->u);
				  if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
						  || (delim && gp->u != prevgp->u)))
	  @@ -571,14 +576,14 @@ selsnap(int *x, int *y, int direction)
			  ,*x = (direction < 0) ? 0 : term.col - 1;
			  if (direction < 0) {
				  for (; *y > 0; *y += direction) {
	  -				if (!(term.line[*y-1][term.col-1].mode
	  +				if (!(TLINE(*y-1)[term.col-1].mode
							  & ATTR_WRAP)) {
						  break;
					  }
				  }
			  } else if (direction > 0) {
				  for (; *y < term.row-1; *y += direction) {
	  -				if (!(term.line[*y][term.col-1].mode
	  +				if (!(TLINE(*y)[term.col-1].mode
							  & ATTR_WRAP)) {
						  break;
					  }
	  @@ -593,7 +598,7 @@ getsel(void)
	   {
		  char *str, *ptr;
		  int y, bufsize, lastx, linelen;
	  -	const Glyph *gp, *last;
	  +	Glyph *gp, *last;
 
		  if (sel.ob.x == -1)
			  return NULL;
	  @@ -609,13 +614,13 @@ getsel(void)
			  }
 
			  if (sel.type == SEL_RECTANGULAR) {
	  -			gp = &term.line[y][sel.nb.x];
	  +			gp = &TLINE(y)[sel.nb.x];
				  lastx = sel.ne.x;
			  } else {
	  -			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
	  +			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
				  lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
			  }
	  -		last = &term.line[y][MIN(lastx, linelen-1)];
	  +		last = &TLINE(y)[MIN(lastx, linelen-1)];
			  while (last >= gp && last->u == ' ')
				  --last;
 
	  @@ -760,7 +765,7 @@ stty(char **args)
	   }
 
	   int
	  -ttynew(const char *line, char *cmd, const char *out, char **args)
	  +ttynew(char *line, char *cmd, char *out, char **args)
	   {
		  int m, s;
 
	  @@ -793,15 +798,14 @@ ttynew(const char *line, char *cmd, const char *out, char **args)
			  break;
		  case 0:
			  close(iofd);
	  -		close(m);
			  setsid(); /* create a new process group */
			  dup2(s, 0);
			  dup2(s, 1);
			  dup2(s, 2);
			  if (ioctl(s, TIOCSCTTY, NULL) < 0)
				  die("ioctl TIOCSCTTY failed: %s\n", strerror(errno));
	  -		if (s > 2)
	  -			close(s);
	  +		close(s);
	  +		close(m);
	   #ifdef __OpenBSD__
			  if (pledge("stdio getpw proc exec", NULL) == -1)
				  die("pledge\n");
	  @@ -851,6 +855,9 @@ void
	   ttywrite(const char *s, size_t n, int may_echo)
	   {
		  const char *next;
	  +	Arg arg = (Arg) { .i = term.scr };
	  +
	  +	kscrolldown(&arg);
 
		  if (may_echo && IS_SET(MODE_ECHO))
			  twrite(s, n, 1);
	  @@ -1062,13 +1069,53 @@ tswapscreen(void)
	   }
 
	   void
	  -tscrolldown(int orig, int n)
	  +kscrolldown(const Arg* a)
	  +{
	  +	int n = a->i;
	  +
	  +	if (n < 0)
	  +		n = term.row + n;
	  +
	  +	if (n > term.scr)
	  +		n = term.scr;
	  +
	  +	if (term.scr > 0) {
	  +		term.scr -= n;
	  +		selscroll(0, -n);
	  +		tfulldirt();
	  +	}
	  +}
	  +
	  +void
	  +kscrollup(const Arg* a)
	  +{
	  +	int n = a->i;
	  +
	  +	if (n < 0)
	  +		n = term.row + n;
	  +
	  +	if (term.scr <= HISTSIZE-n) {
	  +		term.scr += n;
	  +		selscroll(0, n);
	  +		tfulldirt();
	  +	}
	  +}
	  +
	  +void
	  +tscrolldown(int orig, int n, int copyhist)
	   {
		  int i;
		  Line temp;
 
		  LIMIT(n, 0, term.bot-orig+1);
 
	  +	if (copyhist) {
	  +		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
	  +		temp = term.hist[term.histi];
	  +		term.hist[term.histi] = term.line[term.bot];
	  +		term.line[term.bot] = temp;
	  +	}
	  +
		  tsetdirt(orig, term.bot-n);
		  tclearregion(0, term.bot-n+1, term.col-1, term.bot);
 
	  @@ -1078,17 +1125,28 @@ tscrolldown(int orig, int n)
			  term.line[i-n] = temp;
		  }
 
	  -	selscroll(orig, n);
	  +	if (term.scr == 0)
	  +		selscroll(orig, n);
	   }
 
	   void
	  -tscrollup(int orig, int n)
	  +tscrollup(int orig, int n, int copyhist)
	   {
		  int i;
		  Line temp;
 
		  LIMIT(n, 0, term.bot-orig+1);
 
	  +	if (copyhist) {
	  +		term.histi = (term.histi + 1) % HISTSIZE;
	  +		temp = term.hist[term.histi];
	  +		term.hist[term.histi] = term.line[orig];
	  +		term.line[orig] = temp;
	  +	}
	  +
	  +	if (term.scr > 0 && term.scr < HISTSIZE)
	  +		term.scr = MIN(term.scr + n, HISTSIZE-1);
	  +
		  tclearregion(0, orig, term.col-1, orig+n-1);
		  tsetdirt(orig+n, term.bot);
 
	  @@ -1098,7 +1156,8 @@ tscrollup(int orig, int n)
			  term.line[i+n] = temp;
		  }
 
	  -	selscroll(orig, -n);
	  +	if (term.scr == 0)
	  +		selscroll(orig, -n);
	   }
 
	   void
	  @@ -1127,7 +1186,7 @@ tnewline(int first_col)
		  int y = term.c.y;
 
		  if (y == term.bot) {
	  -		tscrollup(term.top, 1);
	  +		tscrollup(term.top, 1, 1);
		  } else {
			  y++;
		  }
	  @@ -1189,9 +1248,9 @@ tmoveto(int x, int y)
	   }
 
	   void
	  -tsetchar(Rune u, const Glyph *attr, int x, int y)
	  +tsetchar(Rune u, Glyph *attr, int x, int y)
	   {
	  -	static const char *vt100_0[62] = { /* 0x41 - 0x7e */
	  +	static char *vt100_0[62] = { /* 0x41 - 0x7e */
			  "↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
			  0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
			  0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
	  @@ -1292,18 +1351,18 @@ void
	   tinsertblankline(int n)
	   {
		  if (BETWEEN(term.c.y, term.top, term.bot))
	  -		tscrolldown(term.c.y, n);
	  +		tscrolldown(term.c.y, n, 0);
	   }
 
	   void
	   tdeleteline(int n)
	   {
		  if (BETWEEN(term.c.y, term.top, term.bot))
	  -		tscrollup(term.c.y, n);
	  +		tscrollup(term.c.y, n, 0);
	   }
 
	   int32_t
	  -tdefcolor(const int *attr, int *npar, int l)
	  +tdefcolor(int *attr, int *npar, int l)
	   {
		  int32_t idx = -1;
		  uint r, g, b;
	  @@ -1353,7 +1412,7 @@ tdefcolor(const int *attr, int *npar, int l)
	   }
 
	   void
	  -tsetattr(const int *attr, int l)
	  +tsetattr(int *attr, int l)
	   {
		  int i;
		  int32_t idx;
	  @@ -1471,9 +1530,9 @@ tsetscroll(int t, int b)
	   }
 
	   void
	  -tsetmode(int priv, int set, const int *args, int narg)
	  +tsetmode(int priv, int set, int *args, int narg)
	   {
	  -	int alt; const int *lim;
	  +	int alt, *lim;
 
		  for (lim = args + narg; args < lim; ++args) {
			  if (priv) {
	  @@ -1736,11 +1795,11 @@ csihandle(void)
			  break;
		  case 'S': /* SU -- Scroll <n> line up */
			  DEFAULT(csiescseq.arg[0], 1);
	  -		tscrollup(term.top, csiescseq.arg[0]);
	  +		tscrollup(term.top, csiescseq.arg[0], 0);
			  break;
		  case 'T': /* SD -- Scroll <n> line down */
			  DEFAULT(csiescseq.arg[0], 1);
	  -		tscrolldown(term.top, csiescseq.arg[0]);
	  +		tscrolldown(term.top, csiescseq.arg[0], 0);
			  break;
		  case 'L': /* IL -- Insert <n> blank lines */
			  DEFAULT(csiescseq.arg[0], 1);
	  @@ -2023,7 +2082,7 @@ void
	   tdumpline(int n)
	   {
		  char buf[UTF_SIZ];
	  -	const Glyph *bp, *end;
	  +	Glyph *bp, *end;
 
		  bp = &term.line[n][0];
		  end = &bp[MIN(tlinelen(n), term.col) - 1];
	  @@ -2252,7 +2311,7 @@ eschandle(uchar ascii)
			  return 0;
		  case 'D': /* IND -- Linefeed */
			  if (term.c.y == term.bot) {
	  -			tscrollup(term.top, 1);
	  +			tscrollup(term.top, 1, 1);
			  } else {
				  tmoveto(term.c.x, term.c.y+1);
			  }
	  @@ -2265,7 +2324,7 @@ eschandle(uchar ascii)
			  break;
		  case 'M': /* RI -- Reverse index */
			  if (term.c.y == term.top) {
	  -			tscrolldown(term.top, 1);
	  +			tscrolldown(term.top, 1, 1);
			  } else {
				  tmoveto(term.c.x, term.c.y-1);
			  }
	  @@ -2475,7 +2534,7 @@ twrite(const char *buf, int buflen, int show_ctrl)
	   void
	   tresize(int col, int row)
	   {
	  -	int i;
	  +	int i, j;
		  int minrow = MIN(row, term.row);
		  int mincol = MIN(col, term.col);
		  int *bp;
	  @@ -2512,6 +2571,14 @@ tresize(int col, int row)
		  term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
		  term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
 
	  +	for (i = 0; i < HISTSIZE; i++) {
	  +		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
	  +		for (j = mincol; j < col; j++) {
	  +			term.hist[i][j] = term.c.attr;
	  +			term.hist[i][j].u = ' ';
	  +		}
	  +	}
	  +
		  /* resize each row to new width, zero-pad if needed */
		  for (i = 0; i < minrow; i++) {
			  term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
	  @@ -2570,7 +2637,7 @@ drawregion(int x1, int y1, int x2, int y2)
				  continue;
 
			  term.dirty[y] = 0;
	  -		xdrawline(term.line[y], x1, y, x2);
	  +		xdrawline(TLINE(y), x1, y, x2);
		  }
	   }
 
	  @@ -2591,8 +2658,9 @@ draw(void)
			  cx--;
 
		  drawregion(0, 0, term.col, term.row);
	  -	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
	  -			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
	  +	if (term.scr == 0)
	  +		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
	  +				term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
		  term.ocx = cx;
		  term.ocy = term.c.y;
		  xfinishdraw();
	  diff --git a/st.h b/st.h
	  index fa2eddf..7ea2fd3 100644
	  --- a/st.h
	  +++ b/st.h
	  @@ -81,6 +81,8 @@ void die(const char *, ...);
	   void redraw(void);
	   void draw(void);
 
	  +void kscrolldown(const Arg *);
	  +void kscrollup(const Arg *);
	   void printscreen(const Arg *);
	   void printsel(const Arg *);
	   void sendbreak(const Arg *);
	  @@ -91,7 +93,7 @@ void tnew(int, int);
	   void tresize(int, int);
	   void tsetdirtattr(int);
	   void ttyhangup(void);
	  -int ttynew(const char *, char *, const char *, char **);
	  +int ttynew(char *, char *, char *, char **);
	   size_t ttyread(void);
	   void ttyresize(int, int);
	   void ttywrite(const char *, size_t, int);
	  @@ -109,7 +111,7 @@ size_t utf8encode(Rune, char *);
 
	   void *xmalloc(size_t);
	   void *xrealloc(void *, size_t);
	  -char *xstrdup(const char *);
	  +char *xstrdup(char *);
 
	   /* config.h globals */
	   extern char *utmp;
	  @@ -123,3 +125,4 @@ extern char *termname;
	   extern unsigned int tabspaces;
	   extern unsigned int defaultfg;
	   extern unsigned int defaultbg;
	  +extern float alpha;
	  diff --git a/x.c b/x.c
	  index 89786b8..5ba2fc7 100644
	  --- a/x.c
	  +++ b/x.c
	  @@ -48,7 +48,7 @@ typedef struct {
	   /* X modifiers */
	   #define XK_ANY_MOD    UINT_MAX
	   #define XK_NO_MOD     0
	  -#define XK_SWITCH_MOD (1<<13|1<<14)
	  +#define XK_SWITCH_MOD (1<<13)
 
	   /* function definitions used in config.h */
	   static void clipcopy(const Arg *);
	  @@ -81,6 +81,7 @@ typedef XftGlyphFontSpec GlyphFontSpec;
	   typedef struct {
		  int tw, th; /* tty width and height */
		  int w, h; /* window width and height */
	  +	int hborderpx, vborderpx;
		  int ch; /* char height */
		  int cw; /* char width  */
		  int mode; /* window state/mode flags */
	  @@ -105,6 +106,7 @@ typedef struct {
		  XSetWindowAttributes attrs;
		  int scr;
		  int isfixed; /* is fixed geometry? */
	  +	int depth; /* bit depth */
		  int l, t; /* left and top offset */
		  int gm; /* geometry mask */
	   } XWindow;
	  @@ -156,7 +158,9 @@ static void xresize(int, int);
	   static void xhints(void);
	   static int xloadcolor(int, const char *, Color *);
	   static int xloadfont(Font *, FcPattern *);
	  -static void xloadfonts(const char *, double);
	  +static void xloadfonts(char *, double);
	  +static int xloadsparefont(FcPattern *, int);
	  +static void xloadsparefonts(void);
	   static void xunloadfont(Font *);
	   static void xunloadfonts(void);
	   static void xsetenv(void);
	  @@ -243,6 +247,7 @@ static char *usedfont = NULL;
	   static double usedfontsize = 0;
	   static double defaultfontsize = 0;
 
	  +static char *opt_alpha = NULL;
	   static char *opt_class = NULL;
	   static char **opt_cmd  = NULL;
	   static char *opt_embed = NULL;
	  @@ -306,6 +311,7 @@ zoomabs(const Arg *arg)
	   {
		  xunloadfonts();
		  xloadfonts(usedfont, arg->f);
	  +	xloadsparefonts();
		  cresize(0, 0);
		  redraw();
		  xhints();
	  @@ -331,7 +337,7 @@ ttysend(const Arg *arg)
	   int
	   evcol(XEvent *e)
	   {
	  -	int x = e->xbutton.x - borderpx;
	  +	int x = e->xbutton.x - win.hborderpx;
		  LIMIT(x, 0, win.tw - 1);
		  return x / win.cw;
	   }
	  @@ -339,7 +345,7 @@ evcol(XEvent *e)
	   int
	   evrow(XEvent *e)
	   {
	  -	int y = e->xbutton.y - borderpx;
	  +	int y = e->xbutton.y - win.vborderpx;
		  LIMIT(y, 0, win.th - 1);
		  return y / win.ch;
	   }
	  @@ -387,9 +393,7 @@ mousereport(XEvent *e)
				  button = 3;
			  } else {
				  button -= Button1;
	  -			if (button >= 7)
	  -				button += 128 - 7;
	  -			else if (button >= 3)
	  +			if (button >= 3)
					  button += 64 - 3;
			  }
			  if (e->xbutton.type == ButtonPress) {
	  @@ -675,6 +679,7 @@ setsel(char *str, Time t)
		  XSetSelectionOwner(xw.dpy, XA_PRIMARY, xw.win, t);
		  if (XGetSelectionOwner(xw.dpy, XA_PRIMARY) != xw.win)
			  selclear();
	  +	clipcopy(NULL);
	   }
 
	   void
	  @@ -723,6 +728,9 @@ cresize(int width, int height)
		  col = MAX(1, col);
		  row = MAX(1, row);
 
	  +	win.hborderpx = (win.w - col * win.cw) / 2;
	  +	win.vborderpx = (win.h - row * win.ch) / 2;
	  +
		  tresize(col, row);
		  xresize(col, row);
		  ttyresize(win.tw, win.th);
	  @@ -736,7 +744,7 @@ xresize(int col, int row)
 
		  XFreePixmap(xw.dpy, xw.buf);
		  xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
	  -			DefaultDepth(xw.dpy, xw.scr));
	  +			xw.depth);
		  XftDrawChange(xw.draw, xw.buf);
		  xclear(0, 0, win.w, win.h);
 
	  @@ -796,6 +804,13 @@ xloadcols(void)
				  else
					  die("could not allocate color %d\n", i);
			  }
	  +
	  +	/* set alpha value of bg color */
	  +	if (opt_alpha)
	  +		alpha = strtof(opt_alpha, NULL);
	  +	dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * alpha);
	  +	dc.col[defaultbg].pixel &= 0x00FFFFFF;
	  +	dc.col[defaultbg].pixel |= (unsigned char)(0xff * alpha) << 24;
		  loaded = 1;
	   }
 
	  @@ -840,8 +855,8 @@ xhints(void)
		  sizeh->flags = PSize | PResizeInc | PBaseSize | PMinSize;
		  sizeh->height = win.h;
		  sizeh->width = win.w;
	  -	sizeh->height_inc = win.ch;
	  -	sizeh->width_inc = win.cw;
	  +	sizeh->height_inc = 1;
	  +	sizeh->width_inc = 1;
		  sizeh->base_height = 2 * borderpx;
		  sizeh->base_width = 2 * borderpx;
		  sizeh->min_height = win.ch + 2 * borderpx;
	  @@ -952,7 +967,7 @@ xloadfont(Font *f, FcPattern *pattern)
	   }
 
	   void
	  -xloadfonts(const char *fontstr, double fontsize)
	  +xloadfonts(char *fontstr, double fontsize)
	   {
		  FcPattern *pattern;
		  double fontval;
	  @@ -960,7 +975,7 @@ xloadfonts(const char *fontstr, double fontsize)
		  if (fontstr[0] == '-')
			  pattern = XftXlfdParse(fontstr, False, False);
		  else
	  -		pattern = FcNameParse((const FcChar8 *)fontstr);
	  +		pattern = FcNameParse((FcChar8 *)fontstr);
 
		  if (!pattern)
			  die("can't open font %s\n", fontstr);
	  @@ -1021,6 +1036,101 @@ xloadfonts(const char *fontstr, double fontsize)
		  FcPatternDestroy(pattern);
	   }
 
	  +int
	  +xloadsparefont(FcPattern *pattern, int flags)
	  +{
	  +	FcPattern *match;
	  +	FcResult result;
	  +	
	  +	match = FcFontMatch(NULL, pattern, &result);
	  +	if (!match) {
	  +		return 1;
	  +	}
	  +
	  +	if (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {
	  +		FcPatternDestroy(match);
	  +		return 1;
	  +	}
	  +
	  +	frc[frclen].flags = flags;
	  +	/* Believe U+0000 glyph will present in each default font */
	  +	frc[frclen].unicodep = 0;
	  +	frclen++;
	  +
	  +	return 0;
	  +}
	  +
	  +void
	  +xloadsparefonts(void)
	  +{
	  +	FcPattern *pattern;
	  +	double sizeshift, fontval;
	  +	int fc;
	  +	char **fp;
	  +
	  +	if (frclen != 0)
	  +		die("can't embed spare fonts. cache isn't empty");
	  +
	  +	/* Calculate count of spare fonts */
	  +	fc = sizeof(font2) / sizeof(*font2);
	  +	if (fc == 0)
	  +		return;
	  +
	  +	/* Allocate memory for cache entries. */
	  +	if (frccap < 4 * fc) {
	  +		frccap += 4 * fc - frccap;
	  +		frc = xrealloc(frc, frccap * sizeof(Fontcache));
	  +	}
	  +
	  +	for (fp = font2; fp - font2 < fc; ++fp) {
	  +	
	  +		if (**fp == '-')
	  +			pattern = XftXlfdParse(*fp, False, False);
	  +		else
	  +			pattern = FcNameParse((FcChar8 *)*fp);
	  +	
	  +		if (!pattern)
	  +			die("can't open spare font %s\n", *fp);
	  +	   		
	  +		if (defaultfontsize > 0) {
	  +			sizeshift = usedfontsize - defaultfontsize;
	  +			if (sizeshift != 0 &&
	  +					FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==
	  +					FcResultMatch) {	
	  +				fontval += sizeshift;
	  +				FcPatternDel(pattern, FC_PIXEL_SIZE);
	  +				FcPatternDel(pattern, FC_SIZE);
	  +				FcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);
	  +			}
	  +		}
	  +	
	  +		FcPatternAddBool(pattern, FC_SCALABLE, 1);
	  +	
	  +		FcConfigSubstitute(NULL, pattern, FcMatchPattern);
	  +		XftDefaultSubstitute(xw.dpy, xw.scr, pattern);
	  +	
	  +		if (xloadsparefont(pattern, FRC_NORMAL))
	  +			die("can't open spare font %s\n", *fp);
	  +	
	  +		FcPatternDel(pattern, FC_SLANT);
	  +		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
	  +		if (xloadsparefont(pattern, FRC_ITALIC))
	  +			die("can't open spare font %s\n", *fp);
	  +			
	  +		FcPatternDel(pattern, FC_WEIGHT);
	  +		FcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);
	  +		if (xloadsparefont(pattern, FRC_ITALICBOLD))
	  +			die("can't open spare font %s\n", *fp);
	  +	
	  +		FcPatternDel(pattern, FC_SLANT);
	  +		FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);
	  +		if (xloadsparefont(pattern, FRC_BOLD))
	  +			die("can't open spare font %s\n", *fp);
	  +	
	  +		FcPatternDestroy(pattern);
	  +	}
	  +}
	  +
	   void
	   xunloadfont(Font *f)
	   {
	  @@ -1105,11 +1215,23 @@ xinit(int cols, int rows)
		  Window parent;
		  pid_t thispid = getpid();
		  XColor xmousefg, xmousebg;
	  +	XWindowAttributes attr;
	  +	XVisualInfo vis;
 
		  if (!(xw.dpy = XOpenDisplay(NULL)))
			  die("can't open display\n");
		  xw.scr = XDefaultScreen(xw.dpy);
	  -	xw.vis = XDefaultVisual(xw.dpy, xw.scr);
	  +
	  +	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0)))) {
	  +		parent = XRootWindow(xw.dpy, xw.scr);
	  +		xw.depth = 32;
	  +	} else {
	  +		XGetWindowAttributes(xw.dpy, parent, &attr);
	  +		xw.depth = attr.depth;
	  +	}
	  +
	  +	XMatchVisualInfo(xw.dpy, xw.scr, xw.depth, TrueColor, &vis);
	  +	xw.vis = vis.visual;
 
		  /* font */
		  if (!FcInit())
	  @@ -1118,13 +1240,16 @@ xinit(int cols, int rows)
		  usedfont = (opt_font == NULL)? font : opt_font;
		  xloadfonts(usedfont, 0);
 
	  +	/* spare fonts */
	  +	xloadsparefonts();
	  +
		  /* colors */
	  -	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
	  +	xw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);
		  xloadcols();
 
		  /* adjust fixed window geometry */
	  -	win.w = 2 * borderpx + cols * win.cw;
	  -	win.h = 2 * borderpx + rows * win.ch;
	  +	win.w = 2 * win.hborderpx + cols * win.cw;
	  +	win.h = 2 * win.vborderpx + rows * win.ch;
		  if (xw.gm & XNegative)
			  xw.l += DisplayWidth(xw.dpy, xw.scr) - win.w - 2;
		  if (xw.gm & YNegative)
	  @@ -1139,19 +1264,15 @@ xinit(int cols, int rows)
			  | ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;
		  xw.attrs.colormap = xw.cmap;
 
	  -	if (!(opt_embed && (parent = strtol(opt_embed, NULL, 0))))
	  -		parent = XRootWindow(xw.dpy, xw.scr);
		  xw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,
	  -			win.w, win.h, 0, XDefaultDepth(xw.dpy, xw.scr), InputOutput,
	  +			win.w, win.h, 0, xw.depth, InputOutput,
				  xw.vis, CWBackPixel | CWBorderPixel | CWBitGravity
				  | CWEventMask | CWColormap, &xw.attrs);
 
		  memset(&gcvalues, 0, sizeof(gcvalues));
		  gcvalues.graphics_exposures = False;
	  -	dc.gc = XCreateGC(xw.dpy, parent, GCGraphicsExposures,
	  -			&gcvalues);
	  -	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,
	  -			DefaultDepth(xw.dpy, xw.scr));
	  +	xw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h, xw.depth);
	  +	dc.gc = XCreateGC(xw.dpy, xw.buf, GCGraphicsExposures, &gcvalues);
		  XSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);
		  XFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);
 
	  @@ -1213,7 +1334,7 @@ xinit(int cols, int rows)
	   int
	   xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)
	   {
	  -	float winx = borderpx + x * win.cw, winy = borderpx + y * win.ch, xp, yp;
	  +	float winx = win.hborderpx + x * win.cw, winy = win.vborderpx + y * win.ch, xp, yp;
		  ushort mode, prevmode = USHRT_MAX;
		  Font *font = &dc.font;
		  int frcflags = FRC_NORMAL;
	  @@ -1346,7 +1467,7 @@ void
	   xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
	   {
		  int charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);
	  -	int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
	  +	int winx = win.hborderpx + x * win.cw, winy = win.vborderpx + y * win.ch,
			  width = charlen * win.cw;
		  Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
		  XRenderColor colfg, colbg;
	  @@ -1436,17 +1557,17 @@ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, i
 
		  /* Intelligent cleaning up of the borders. */
		  if (x == 0) {
	  -		xclear(0, (y == 0)? 0 : winy, borderpx,
	  +		xclear(0, (y == 0)? 0 : winy, win.vborderpx,
				  winy + win.ch +
	  -			((winy + win.ch >= borderpx + win.th)? win.h : 0));
	  +			((winy + win.ch >= win.vborderpx + win.th)? win.h : 0));
		  }
	  -	if (winx + width >= borderpx + win.tw) {
	  +	if (winx + width >= win.hborderpx + win.tw) {
			  xclear(winx + width, (y == 0)? 0 : winy, win.w,
	  -			((winy + win.ch >= borderpx + win.th)? win.h : (winy + win.ch)));
	  +			((winy + win.ch >= win.vborderpx + win.th)? win.h : (winy + win.ch)));
		  }
		  if (y == 0)
	  -		xclear(winx, 0, winx + width, borderpx);
	  -	if (winy + win.ch >= borderpx + win.th)
	  +		xclear(winx, 0, winx + width, win.hborderpx);
	  +	if (winy + win.ch >= win.vborderpx + win.th)
			  xclear(winx, winy + win.ch, winx + width, win.h);
 
		  /* Clean up the region we want to draw to. */
	  @@ -1540,35 +1661,35 @@ xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
			  case 3: /* Blinking Underline */
			  case 4: /* Steady Underline */
				  XftDrawRect(xw.draw, &drawcol,
	  -					borderpx + cx * win.cw,
	  -					borderpx + (cy + 1) * win.ch - \
	  +					win.hborderpx + cx * win.cw,
	  +					win.vborderpx + (cy + 1) * win.ch - \
							  cursorthickness,
						  win.cw, cursorthickness);
				  break;
			  case 5: /* Blinking bar */
			  case 6: /* Steady bar */
				  XftDrawRect(xw.draw, &drawcol,
	  -					borderpx + cx * win.cw,
	  -					borderpx + cy * win.ch,
	  +					win.hborderpx + cx * win.cw,
	  +					win.vborderpx + cy * win.ch,
						  cursorthickness, win.ch);
				  break;
			  }
		  } else {
			  XftDrawRect(xw.draw, &drawcol,
	  -				borderpx + cx * win.cw,
	  -				borderpx + cy * win.ch,
	  +				win.hborderpx + cx * win.cw,
	  +				win.vborderpx + cy * win.ch,
					  win.cw - 1, 1);
			  XftDrawRect(xw.draw, &drawcol,
	  -				borderpx + cx * win.cw,
	  -				borderpx + cy * win.ch,
	  +				win.hborderpx + cx * win.cw,
	  +				win.vborderpx + cy * win.ch,
					  1, win.ch - 1);
			  XftDrawRect(xw.draw, &drawcol,
	  -				borderpx + (cx + 1) * win.cw - 1,
	  -				borderpx + cy * win.ch,
	  +				win.hborderpx + (cx + 1) * win.cw - 1,
	  +				win.vborderpx + cy * win.ch,
					  1, win.ch - 1);
			  XftDrawRect(xw.draw, &drawcol,
	  -				borderpx + cx * win.cw,
	  -				borderpx + (cy + 1) * win.ch - 1,
	  +				win.hborderpx + cx * win.cw,
	  +				win.vborderpx + (cy + 1) * win.ch - 1,
					  win.cw, 1);
		  }
	   }
	  @@ -1588,9 +1709,8 @@ xseticontitle(char *p)
		  XTextProperty prop;
		  DEFAULT(p, opt_title);
 
	  -	if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
	  -	                                &prop) != Success)
	  -		return;
	  +	Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
	  +			&prop);
		  XSetWMIconName(xw.dpy, xw.win, &prop);
		  XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmiconname);
		  XFree(prop.value);
	  @@ -1602,9 +1722,8 @@ xsettitle(char *p)
		  XTextProperty prop;
		  DEFAULT(p, opt_title);
 
	  -	if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
	  -	                                &prop) != Success)
	  -		return;
	  +	Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
	  +			&prop);
		  XSetWMName(xw.dpy, xw.win, &prop);
		  XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmname);
		  XFree(prop.value);
	  @@ -2006,6 +2125,9 @@ main(int argc, char *argv[])
		  case 'a':
			  allowaltscreen = 0;
			  break;
	  +	case 'A':
	  +		opt_alpha = EARGF(usage());
	  +		break;
		  case 'c':
			  opt_class = EARGF(usage());
			  break;

	#+end_src
* Wayland
  I need this on my [[https://k1sslinux.org][KISS linux]] systems where I use Wayland.
** Sway
   :PROPERTIES:
   :header-args:conf: :tangle sway/config
   :END:
   Remove borders around windows.
   #+begin_src conf
	 default_border none
   #+end_src
   Define useful variables I'll use across the config, namely the
   modifier: =Mod4= and the default terminal emulator: =foot=.
   #+begin_src conf
	 ### Variables
	 #
	 # Logo key. Use Mod1 for Alt.
	 set $mod Mod4
	 # Home row direction keys, like vim
	 set $left h
	 set $down j
	 set $up k
	 set $right l
	 # Your preferred terminal emulator
	 set $term foot
   #+end_src
*** Outputs
	Sway handles multi monitor screens in a very weird way, so these
	days I prefer [[https://github.com/djpholy/dwl][dwl]]. The only problem with dwl is that it crashes
	when I run graphical emacs (compiled from the =feature/pgtk=
	branch).
	#+NAME: outputs
	#+begin_src emacs-lisp
	  (if (string= mf/host-machine "desktop")
		  "### Output configuration#

	  #
	  # Example configuration:
	  #
	  #   output HDMI-A-1 resolution 1920x1080 position 1920,0
	  #
	  # You can get the names of your outputs by running: swaymsg -t get_outputs
	  output * bg /home/mario/Downloads/wallhaven-282plm.jpg fill
	  output VGA-1 resolution 1920x1200 position 0,0
	  output HDMI-A-1 resolution 1920x1080 position 1920,0

	  workspace 1 output VGA-1
	  workspace 2 output VGA-1
	  workspace 3 output HDMI-A-1
	  workspace 4 output HDMI-A-1"
	  "### Output configuration#

	  #
	  # Example configuration:
	  #
	  #   output HDMI-A-1 resolution 1920x1080 position 1920,0
	  #
	  # You can get the names of your outputs by running: swaymsg -t get_outputs
	  output * bg /home/mario/Downloads/wallhaven-282plm.jpg fill")
	#+end_src

	#+begin_src conf :noweb yes
	  <<outputs()>>
	  ### Input configuration
	  input * {
			xkb_layout "dvorak"
			xkb_options "ctrl:nocaps,ctrl:swapcaps"
	  }
	#+end_src
*** Key bindings
	I use the same keybindings I set up in the dwm section above.
	#+begin_src conf
	  ### Key bindings
	  #
	  # Basics:
	  #
		  # Start a terminal
		  bindsym $mod+Return exec $term

		  # Kill focused window
		  bindsym $mod+q kill

		  # Start your launcher
		  bindsym $mod+r exec /usr/bin/bemenu-run

		  # Start a web browser
		  bindsym $mod+w exec /usr/bin/firefox

		  # Start emacs
		  # bindsym $mod+e exec /usr/bin/emacs-28.0.50

		  # Drag floating windows by holding down $mod and left mouse button.
		  # Resize them with right mouse button + $mod.
		  # Despite the name, also works for non-floating windows.
		  # Change normal to inverse to use left mouse button for resizing and right
		  # mouse button for dragging.
		  floating_modifier $mod normal

		  # Reload the configuration file
		  bindsym $mod+Shift+R reload

	  #
	  # Moving around:
	  #
		  # Move your focus around
		  bindsym $mod+$left focus left
		  bindsym $mod+$down focus down
		  bindsym $mod+$up focus up
		  bindsym $mod+$right focus right

		  # Move the focused window with the same, but add Shift
		  bindsym $mod+Shift+$left move left
		  bindsym $mod+Shift+$down move down
		  bindsym $mod+Shift+$up move up
		  bindsym $mod+Shift+$right move right
	  #
	  # Workspaces:
	  #
		  # Switch to workspace
		  bindsym $mod+1 workspace number 1
		  bindsym $mod+2 workspace number 2
		  bindsym $mod+3 workspace number 3
		  bindsym $mod+4 workspace number 4
		  # Move focused container to workspace
		  bindsym $mod+Shift+1 move container to workspace number 1
		  bindsym $mod+Shift+2 move container to workspace number 2
		  bindsym $mod+Shift+3 move container to workspace number 3
		  bindsym $mod+Shift+4 move container to workspace number 4
	  #
	  # Layout stuff:
	  #
		  # You can "split" the current object of your focus with
		  # $mod+b or $mod+v, for horizontal and vertical splits
		  # respectively.
		  bindsym $mod+b splitv
		  bindsym $mod+v splith

		  # Switch the current container between different layout styles
		  bindsym $mod+s layout stacking
		  bindsym $mod+t layout tabbed
		  bindsym $mod+e layout toggle split

		  # Make the current focus fullscreen
		  bindsym $mod+f fullscreen

		  # Toggle the current focus between tiling and floating mode
		  bindsym $mod+Shift+space floating toggle

		  # Swap focus between the tiling area and the floating area
		  bindsym $mod+space focus mode_toggle

		  # Move focus to the parent container
		  bindsym $mod+a focus parent
	#+end_src
*** Rules
	As in my dwm setup I only need two rules: one to move firefox to
	workspace 2, the other one to move mpv to workspace 3.
	#+begin_src conf
	  # Rules
	  assign [title="mpv"] → workspace 3
	  assign [title="Firefox"] → workspace 2
	#+end_src
*** TODO Status bar
	Provide a very simple status bar configuration for =swaybar=.
	TODO: Use acme theme
	#+begin_src conf
	  #
	  # Status Bar:
	  #
	  # Read `man 5 sway-bar` for more information about this section.
	  bar {
		  position top

		  # When the status_command prints a new line to stdout, swaybar updates.
		  # The default just shows the current date and time.
		  status_command while date +'%d-%m-%Y %H:%M'; do sleep 60; done

		  colors {
			  statusline #ffffff
			  background #000000
			  inactive_workspace #323232 #323232 #5c5c5c
		  }
	  }

	  include @sysconfdir@/sway/config.d/*
	#+end_src
** Foot
   :PROPERTIES:
   :header-args:conf: :tangle foot/foot.ini
   :END:
   Setup fonts and general variables.
   #+begin_src conf
	 font=<<font>>-regular:size=<<font-size()>>
	 pad=0x0 # optionally append 'center'
	 notify=
	 bold-text-in-bright=yes
	 workers=2

	 [url]
	 # launch=xdg-open ${url}
	 # label-letters=sadfjklewcmpgh
	 # osc8-underline=url-mode
	 # protocols=http, https, ftp, ftps, file, gemini, gopher
	 #
	 uri-characters=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.,~:;/?#@!$&%*+="'
   #+end_src
   Setup the color theme, in particular when running emacs in the
   terminal I have to have a black background not a grey one, which
   is the default (why?).
   TODO: Use acme theme
   #+begin_src conf
	 [colors]
	 alpha=0.9
	 regular0=000000 # black
	 regular7=ffffff # white
   #+end_src
